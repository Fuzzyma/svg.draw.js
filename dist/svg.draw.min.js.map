{"version":3,"file":"svg.draw.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/createClass.js","../src/svg.draw.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../src/circle.js","../src/rectable.js","../src/ellipse.js","../src/lineable.js"],"sourcesContent":["function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import { Element, extend, on, off, regex } from '@svgdotjs/svg.js'\n\nconst defaults = { snapToGrid: 1 }\nlet drawPlugins = {}\n\n// Our Object which manages drawing\nclass PaintHandler {\n\n  constructor (el, event, options) {\n\n    this.el = el\n    el.remember('_paintHandler', this)\n\n    this.start = this.start.bind(this)\n    this.point = this.point.bind(this)\n    this.stop = this.stop.bind(this)\n    this.update = this.update.bind(this)\n    this.done = this.done.bind(this)\n    this.cancel = this.cancel.bind(this)\n\n    var plugin = this.getPlugin()\n\n    this.parent = el.parent()\n    this.p = this.parent.node.createSVGPoint() // Helping point for coord transformation\n    this.m = null // transformation matrix. We get it when drawing starts\n    this.startPoint = null\n    this.lastUpdateCall = null\n    this.options = {}\n\n    // Merge options and defaults\n    for (var i in defaults) {\n      this.options[i] = defaults[i]\n      if (typeof options[i] !== 'undefined') {\n        this.options[i] = options[i]\n      }\n    }\n\n    if (plugin.point) {\n      plugin['pointPlugin'] = plugin.point\n      delete plugin.point\n    }\n\n    // Import all methods from plugin into object\n    for (var j in plugin) {\n      this[j] = plugin[j]\n    }\n\n    // When we got an event, we use this for start, otherwise we use the click-event as default\n    if (!event) {\n      this.parent.on('click.draw', this.start)\n    }\n\n  }\n\n  transformPoint (x, y) {\n\n    this.p.x = x - (this.offset.x - window.pageXOffset)\n    this.p.y = y - (this.offset.y - window.pageYOffset)\n\n    return this.p.matrixTransform(this.m)\n\n  }\n\n  start (event) {\n    // get the current transform matrix from screen to element (offset corrected)\n    this.m = this.el.node.getScreenCTM().inverse()\n\n    // we save the current scrolling-offset here\n    this.offset = { x: window.pageXOffset, y: window.pageYOffset }\n\n    // we want to snap in screen-coords, so we have to scale the snapToGrid accordingly\n    this.options.snapToGrid *= Math.sqrt(this.m.a * this.m.a + this.m.b * this.m.b)\n\n    // save the startpoint\n    this.startPoint = this.snapToGrid(this.transformPoint(event.clientX, event.clientY))\n\n    // the plugin may do some initial work\n    if (this.init) { this.init(event) }\n\n    // Fire our `drawstart`-event. We send the offset-corrected cursor-position along\n    this.el.fire('drawstart', { event: event, p: this.p, m: this.m })\n\n    // We need to bind the update-function to the mousemove event to keep track of the cursor\n    on(window, 'mousemove.draw', this.update)\n\n    // Every consecutive call to start should map to point now\n    this.start = this.point\n\n  }\n\n  // This function draws a point if the element is a polyline or polygon\n  // Otherwise it will just stop drawing the shape cause we are done\n  point (event) {\n    if (this.point !== this.start) {\n      return this.start(event)\n    }\n    if (this.pointPlugin) {\n      return this.pointPlugin(event)\n    }\n\n    // If this function is not overwritten we just call stop\n    this.stop(event)\n  }\n\n  // The stop-function does the cleanup work\n  stop (event) {\n    if (event) {\n      this.update(event)\n    }\n\n    // Plugin may want to clean something\n    if (this.clean) { this.clean() }\n\n    // Unbind from all events\n    off(window, 'mousemove.draw')\n    this.parent.off('click.draw')\n\n    // remove Refernce to PaintHandler\n    this.el.forget('_paintHandler')\n\n    // overwrite draw-function since we never need it again for this element\n    this.el.draw = function () {\n    }\n\n    // Fire the `drawstop`-event\n    this.el.fire('drawstop')\n  }\n\n  // Updates the element while moving the cursor\n  update (event) {\n\n    if (!event && this.lastUpdateCall) {\n      event = this.lastUpdateCall\n    }\n\n    this.lastUpdateCall = event\n\n    // Get the current transform matrix\n    // it could have been changed since the start or the last update call\n    this.m = this.el.node.getScreenCTM().inverse()\n\n    // Call the calc-function which calculates the new position and size\n    this.calc(event)\n\n    // Fire the `drawupdate`-event\n    this.el.fire('drawupdate', { event: event, p: this.p, m: this.m })\n  }\n\n  // Called from outside. Finishs a poly-element\n  done () {\n    this.calc()\n    this.stop()\n\n    this.el.fire('drawdone')\n  }\n\n  // Called from outside. Cancels a poly-element\n  cancel () {\n    // stop drawing and remove the element\n    this.stop()\n    this.el.remove()\n\n    this.el.fire('drawcancel')\n  }\n\n  // Calculate the corrected position when using `snapToGrid`\n  snapToGrid (draw) {\n\n    var temp = null\n\n    // An array was given. Loop through every element\n    if (draw.length) {\n      temp = [draw[0] % this.options.snapToGrid, draw[1] % this.options.snapToGrid]\n      draw[0] -= temp[0] < this.options.snapToGrid / 2 ? temp[0] : temp[0] - this.options.snapToGrid\n      draw[1] -= temp[1] < this.options.snapToGrid / 2 ? temp[1] : temp[1] - this.options.snapToGrid\n      return draw\n    }\n\n    // Properties of element were given. Snap them all\n    for (var i in draw) {\n      temp = draw[i] % this.options.snapToGrid\n      draw[i] -= (temp < this.options.snapToGrid / 2 ? temp : temp - this.options.snapToGrid) + (temp < 0 ? this.options.snapToGrid : 0)\n    }\n\n    return draw\n  }\n\n  param (key, value) {\n    this.options[key] = value === null ? defaults[key] : value\n    this.update()\n  }\n\n  // Returns the plugin\n  getPlugin () {\n    return drawPlugins[this.el.type]\n  }\n}\n\nexport function registerPlugin (name, obj) {\n  var plugins = {}\n  if (typeof name === 'string') {\n    plugins[name] = obj\n  } else {\n    plugins = name\n  }\n\n  for (var shapes in plugins) {\n    var shapesArr = shapes.trim().split(regex.delimiter)\n\n    for (var i in shapesArr) {\n      drawPlugins[shapesArr[i]] = plugins[shapes]\n    }\n  }\n}\n\nextend(Element, {\n  // Draw element with mouse\n  draw (event, options, value) {\n\n    // sort the parameters\n    if (!(event instanceof window.Event || typeof event === 'string')) {\n      options = event\n      event = null\n    }\n\n    // get the old Handler or create a new one from event and options\n    var paintHandler = this.remember('_paintHandler') || new PaintHandler(this, event, options || {})\n\n    // When we got an event we have to start/continue drawing\n    if (event instanceof window.Event) {\n      paintHandler['start'](event)\n    }\n\n    // if event is located in our PaintHandler we handle it as method\n    if (paintHandler[event]) {\n      paintHandler[event](options, value)\n    }\n\n    return this\n  }\n\n})\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import { registerPlugin } from './svg.draw.js'\n\nregisterPlugin('circle', {\n\n  init: function (e) {\n\n    var p = this.startPoint\n\n    this.el.attr({ cx: p.x, cy: p.y, r: 1 })\n  },\n\n  // We determine the radius by the cursor position\n  calc: function (e) {\n\n    var p = this.transformPoint(e.clientX, e.clientY)\n    var circle = {\n      cx: this.startPoint.x,\n      cy: this.startPoint.y,\n\n      // calculating the radius\n      r: Math.sqrt(\n        (p.x - this.startPoint.x) * (p.x - this.startPoint.x)\n                        + (p.y - this.startPoint.y) * (p.y - this.startPoint.y)\n      )\n    }\n\n    this.snapToGrid(circle)\n    this.el.attr(circle)\n  }\n\n})\n","import { registerPlugin } from './svg.draw.js'\n\nregisterPlugin('rect image', {\n\n  init: function (e) {\n\n    var p = this.startPoint\n\n    this.el.attr({ x: p.x, y: p.y, height: 0, width: 0 })\n  },\n\n  calc: function (e) {\n\n    var rect = {\n      x: this.startPoint.x,\n      y: this.startPoint.y\n    }; var p = this.transformPoint(e.clientX, e.clientY)\n\n    rect.width = p.x - rect.x\n    rect.height = p.y - rect.y\n\n    // Snap the params to the grid we specified\n    this.snapToGrid(rect)\n\n    // When width is less than zero, we have to draw to the left\n    // which means we have to move the start-point to the left\n    if (rect.width < 0) {\n      rect.x = rect.x + rect.width\n      rect.width = -rect.width\n    }\n\n    // ...same with height\n    if (rect.height < 0) {\n      rect.y = rect.y + rect.height\n      rect.height = -rect.height\n    }\n\n    // draw the element\n    this.el.attr(rect)\n  }\n\n})\n","import { registerPlugin } from './svg.draw.js'\n\nregisterPlugin('ellipse', {\n\n  init: function (e) {\n    // We start with a circle with radius 1 at the position of the cursor\n    var p = this.startPoint\n\n    this.el.attr({ cx: p.x, cy: p.y, rx: 1, ry: 1 })\n\n  },\n\n  calc: function (e) {\n    var p = this.transformPoint(e.clientX, e.clientY)\n\n    var ellipse = {\n      cx: this.startPoint.x,\n      cy: this.startPoint.y,\n      rx: Math.abs(p.x - this.startPoint.x),\n      ry: Math.abs(p.y - this.startPoint.y)\n    }\n\n    this.snapToGrid(ellipse)\n    this.el.attr(ellipse)\n  }\n\n})\n","import { List } from '@svgdotjs/svg.js'\nimport { registerPlugin } from './svg.draw.js'\n\nregisterPlugin('line polyline polygon', {\n\n  init: function () {\n    // When we draw a polygon, we immediately need 2 points.\n    // One start-point and one point at the mouse-position\n\n    this.set = new List()\n\n    var p = this.startPoint\n    var arr = [\n      [p.x, p.y],\n      [p.x, p.y]\n    ]\n\n    this.el.plot(arr)\n\n    // We draw little circles around each point\n    // This is absolutely not needed and maybe removed in a later release\n    this.drawCircles()\n\n  },\n\n  // The calc-function sets the position of the last point to the mouse-position (with offset ofc)\n  calc: function (e) {\n    var arr = this.el.array().valueOf()\n    arr.pop()\n\n    if (e) {\n      var p = this.transformPoint(e.clientX, e.clientY)\n      arr.push(this.snapToGrid([p.x, p.y]))\n    }\n\n    this.el.plot(arr)\n    this.drawCircles()\n  },\n\n  point: function (e) {\n\n    if (this.el.type.indexOf('poly') > -1) {\n      // Add the new Point to the point-array\n      var p = this.transformPoint(e.clientX, e.clientY)\n      var arr = this.el.array().valueOf()\n\n      arr.push(this.snapToGrid([p.x, p.y]))\n\n      this.el.plot(arr)\n      this.drawCircles()\n\n      // Fire the `drawpoint`-event, which holds the coords of the new Point\n      this.el.fire('drawpoint', { event: e, p: { x: p.x, y: p.y }, m: this.m })\n\n      return\n    }\n\n    // We are done, if the element is no polyline or polygon\n    this.stop(e)\n\n  },\n\n  clean: function () {\n\n    // Remove all circles\n    this.set.each(function () {\n      this.remove()\n    })\n\n    delete this.set\n\n  },\n\n  drawCircles: function () {\n    var array = this.el.array().valueOf()\n\n    this.set.each(function () {\n      this.remove()\n    })\n\n    this.set = new List()\n\n    for (var i = 0; i < array.length; ++i) {\n\n      this.p.x = array[i][0]\n      this.p.y = array[i][1]\n\n      var p = this.p.matrixTransform(this.parent.node.getScreenCTM().inverse().multiply(this.el.node.getScreenCTM()))\n\n      this.set.push(this.parent.circle(5).stroke({ width: 1 }).fill('#ccc').center(p.x, p.y))\n    }\n  },\n\n  undo: function () {\n    if (this.set.length) {\n      this.set.splice(-2, 1)[0].remove()\n      this.el.array().value.splice(-2, 1)\n      this.el.plot(this.el.array())\n      this.el.fire('undopoint')\n    }\n  }\n})\n"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","defaults","snapToGrid","drawPlugins","PaintHandler","el","event","options","instance","Constructor","TypeError","remember","this","start","bind","point","stop","update","done","cancel","plugin","getPlugin","parent","p","node","createSVGPoint","m","startPoint","lastUpdateCall","j","on","protoProps","staticProps","prototype","x","y","offset","window","pageXOffset","pageYOffset","matrixTransform","getScreenCTM","inverse","Math","sqrt","a","b","transformPoint","clientX","clientY","init","fire","pointPlugin","clean","off","forget","draw","calc","remove","temp","value","type","registerPlugin","name","obj","plugins","shapes","shapesArr","trim","split","regex","delimiter","Element","Event","paintHandler","e","attr","cx","cy","r","circle","height","width","rect","rx","ry","ellipse","abs","set","List","arr","plot","drawCircles","array","valueOf","pop","push","indexOf","each","multiply","stroke","fill","center","undo","splice"],"mappings":"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"}